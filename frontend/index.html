<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <script src="https://unpkg.com/konva@8.3.12/konva.min.js"></script>
    <!-- jQuery -->
    <script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
    <!-- PapaParse -->
    <script src="scripts/papaparse.min.js"></script>
    <title>ReGrail</title>
    <style>
      table, th, td {
        border: 1px solid black;
        border-collapse: collapse;
      }
    </style>
  </head>
  <body>
  <div>
    <div id="block-select-container" style="position:absolute;top:5px;left:5px;z-index:2">
      <label for="block-select">New Block:</label>
      <select name="block-select" id="block-select">
        <option value="data-source">Data Source</option>
        <option value="join">Join</option>
      </select>
      <!-- These will not be harcoded in the future, obviously. -->
      <input type="file" name="data-select" id="data-select" />
      <button id="add-block" type="button">Add</button>
    </div>

    <div id="flow"></div>

    <table id="data-table" style="max-width:33%;max-height:50%;overflow:scroll;display:block;margin:auto;position:absolute;top:0px;right:0px;"></table>
  </div>
	<script>
    $( document ).ready(function(){
      var width = window.innerWidth;
      var height = window.innerHeight;

      $( document ).on('change', '#block-select', function(){
        var select_value = $('#block-select').val();
        if (select_value == 'data-source'){
          $('#data-select').show();
        } else {
          $('#data-select').hide();
        }
      })

      var stage = new Konva.Stage({
        container: 'flow',
        width: width,
        height: height,
      });

      var blocks = {};
      var connections = {};
      edges = []; // convention: {from: block_id, to: block_id, connector: connector_id}
      var block_data = {}; // convention: {header: Array(...), data: Array(Array()...Array())}

      $.fn.blockFactory = function(type, source=null){
        var block_id = "block-" + Math.random().toString(16).slice(2);

        var layer = new Konva.Layer({
          draggable: true,
          id: block_id
        });

        // var rectX = stage.width() / 2 ;
        // var rectY = stage.height() / 2 ;
        var rectX = 50;
        var rectY = 50;

        var box = new Konva.Rect({
          x: rectX,
          y: rectY,
          width: 100,
          height: 50,
          fill: '#00D2FF',
          stroke: 'black',
          strokeWidth: 4,
          name: 'box'
        });

        var x_circle = new Konva.Circle({
          radius: 10,
          x: rectX,
          y: rectY,
          fill: 'red',
          stroke: 'black'
        });

        var x_text = new Konva.Text({
          text: 'X',
          x: rectX - 4,
          y: rectY - 4
        });

        var edge_circle = new Konva.Circle({
          radius: 10,
          x: rectX + 50,
          y: rectY + 50,
          fill: 'green',
          stroke: 'black',
          name: 'edge_circle'
        });

        var edge_text = new Konva.Text({
          text: '+',
          x: rectX + 47,
          y: rectY + 46,
          name: 'edge_text'
        });

        var block_text = new Konva.Text({
          text: type=='data-source' ? source.split('\\')[source.split('\\').length - 1] : type,
          x: rectX + 18,
          y: rectY + 20,
          name: 'box_text'
        });

        // add cursor styling
        layer.on('mouseover', function () {
          document.body.style.cursor = 'pointer';
        });
        layer.on('mouseout', function () {
          document.body.style.cursor = 'default';
        });

        layer.on('dragend', function() {
          $.fn.reRenderConnections(block_id);
        })

        x_circle.on('click', function () {
          $.fn.removeBlock(layer);
        });

        x_text.on('click', function () {
          $.fn.removeBlock(layer);
        });

        layer.add(box);
        layer.add(x_circle);
        layer.add(x_text);
        layer.add(edge_circle);
        layer.add(edge_text);
        layer.add(block_text);

        return layer;
      }

      var drawing_connection = false;
      var from_block = null;
      var line_layer;
      var line;

      var selected_block_id = null;

      $.fn.startDrawingConnection = function(edge_circle){
        var connector_id = "connector-" + Math.random().toString(16).slice(2);

        line_layer = new Konva.Layer({
          draggable: false,
          id: connector_id
        });

        drawing_connection = true;
        from_block = edge_circle.parent.attrs.id;

        const pos = stage.getPointerPosition();

        line = new Konva.Arrow({
          stroke: 'black',
          listening: false,
          points: [edge_circle.absolutePosition().x, edge_circle.absolutePosition().y, pos.x, pos.y],
          name: 'line'
        });

        line_layer.add(line);

        stage.add(line_layer);
      }

      $.fn.stopDrawingConnection = function(box){
        if(!drawing_connection){
          return;
        }

        var connector_id = line_layer.attrs.id
        var to_block = box.parent.attrs.id;
        var edge = {'from':from_block, 'to':to_block, 'connector': connector_id};

        let found = 0;
        for (const edge of edges) {
          if (edge['from'] == from_block && edge['to'] == to_block){
            found = 1;
          }
        }

        if(!found){
          edges.push(edge);

          const points = line.points().slice();
          points[2] = box.absolutePosition().x + box.attrs.width / 2;
          points[3] = box.absolutePosition().y;
          line.points(points);
          line_layer.batchDraw();

          connections[connector_id] = line_layer;
        } else {
          line.destroy();
          line_layer.draw();
          line = null;
          line_layer = null;
        }
        // TODO: handle cycles

        drawing_connection = false;
        from_block = null;
      }

      $.fn.reRenderConnection = (edge) => {
        let from_x;
        let from_y;
        for(const child of blocks[edge['from']].children){
          if (child.attrs.name == 'edge_circle'){
            from_x = child.absolutePosition().x;
            from_y = child.absolutePosition().y;
          }
        }

        let to_x;
        let to_y;
        for(const child of blocks[edge['to']].children){
          if (child.attrs.name == 'box'){
            to_x = child.absolutePosition().x + child.attrs.width / 2;
            to_y = child.absolutePosition().y;
          }
        }

        for(const child of connections[edge['connector']].children){
          if (child.attrs.name == 'line'){
            child.points([from_x, from_y, to_x, to_y]);
          }
        }
        connections[edge['connector']].batchDraw();
      }

      $.fn.reRenderConnections = (block_id) => {
        for (const edge of edges) {
          if (edge['from'] == block_id || edge['to'] == block_id){
            $.fn.reRenderConnection(edge);
          }
        }
      }

      stage.on('mousemove', (e) => {
        if (!drawing_connection){
          return;
        }
        const pos = stage.getPointerPosition();
        const points = line.points().slice();
        points[2] = pos.x;
        points[3] = pos.y;
        line.points(points);
        line_layer.batchDraw();
      });

      stage.on('click', (e) => {
        if (!drawing_connection && (e.target.hasName('edge_circle') || e.target.hasName('edge_text'))) {
          var target = e.target;
          if (e.target.hasName('edge_text')){
            for(const child of e.target.parent.children){
              if (child.attrs.name == 'edge_circle'){
                target = child;
              }
            }
          }
          $.fn.startDrawingConnection(target);
        }
        else if (drawing_connection && (e.target.hasName('box') || e.target.hasName('box_text'))){
          $.fn.stopDrawingConnection(e.target);
        }
        else if (drawing_connection) {
          line.destroy();
          line_layer.draw();
          line = null;
          line_layer = null;
          drawing_connection = false;
          from_block = null;
        }
        else if (!drawing_connection && (e.target.hasName('box') || e.target.hasName('box_text')) && !e.target.hasName('edge_circle') && !e.target.hasName('edge_text')){
          $.fn.toggleSelectedBlock(e.target.parent);
        }
      })

      $( document ).on('click', '#add-block', function(){
        var block_type = $('#block-select').val();
        if (block_type == 'data-source'){
          var data_source = $('#data-select').val();

          if (data_source == undefined || data_source == ""){
            window.alert("You must select a data source.")
          }
          else{
            var block = $.fn.blockFactory(block_type, data_source);
            var id = block.attrs.id;
            blocks[id] = block;
            stage.add(block);

            var file = document.getElementById('data-select').files[0];

            var d = Papa.parse(file, {
              header: true,
              download: true,
              dynamicTyping: true,
              complete: function(results){
                $.fn.assignDataToBlock(id, results.meta.fields, results.data);
                // $.fn.populateTable(results.meta.fields, results.data);
              }
            });
          }
        } else {
          var data_source = null;

          var block = $.fn.blockFactory(block_type, data_source);
          var id = block.attrs.id;
          blocks[block.attrs.id] = block;
          stage.add(block);
        }
      });

      $.fn.removeBlock = (block) => {
        var indices_to_remove = [];
        var index = 0;
        // first loop through the edges to destroy the connector and track
        // which edges to remove from the array
        for (const edge of edges){
          if (edge['to'] == block.attrs.id || edge['from'] == block.attrs.id){
            connections[edge['connector']].destroy();
            delete connections[edge['connector']];
            indices_to_remove.push(index);
          }
          index += 1;
        }
        for (var i = indices_to_remove.length - 1; i >= 0; i--) {
          edges.splice(indices_to_remove[i], 1);
        }

        // now remove the block
        block.destroy();
        delete blocks[block.attrs.id];
        document.body.style.cursor = 'default';
      }

      $.fn.assignDataToBlock = (block_id, header, data) => {
        block_data[block_id] = {"header": header, "data": data};
      }

      $.fn.populateTable = (header, data) => {
        document.getElementById('data-table').replaceChildren();
        var headerRow = document.createElement('tr');
        for (const item of header){
          var cell = document.createElement('th');
          cell.innerHTML = item;
          headerRow.appendChild(cell);
        }
        document.getElementById('data-table').appendChild(headerRow);

        for (const row of data){
          var tableRow = document.createElement('tr');
          for (const item of Object.values(row)){
            var cell = document.createElement('td');
            cell.innerHTML = item;
            tableRow.append(cell);
          }
          document.getElementById('data-table').appendChild(tableRow);
        }
      }

      $.fn.clearTable = () => {
        document.getElementById('data-table').replaceChildren();
      }

      // $( '#add-block' ).click();

      $.fn.setBlockStroke = function(block_id, color){
        for (const child of blocks[block_id].children){
          if (child.attrs.name == 'box'){
            console.log(child);
            child.stroke(color);
          }
        }
      }

      $.fn.toggleSelectedBlock = function(block) {
        console.log(selected_block_id);
        console.log(blocks);
        if (selected_block_id != block.attrs.id){
          if (selected_block_id != null){
            $.fn.setBlockStroke(selected_block_id, 'black');
          }
          $.fn.setBlockStroke(block.attrs.id, 'yellow');
          selected_block_id = block.attrs.id;
          $.fn.populateTable(block_data[block.attrs.id]['header'], block_data[block.attrs.id]['data'])
        }
        else {
          $.fn.setBlockStroke(block.attrs.id, 'black');
          selected_block_id = null;
          $.fn.clearTable();
        }
      }

  });
  </script>
  </body>
</html>
